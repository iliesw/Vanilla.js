const { RenderPage, setDevClient, setComponentsPath, setPagesPath, RefreshComponents, setPort, setAssetsPath, RefreshPages, GetComponents } = require("./Render.js");
const { BuildFonts } = require("./CssUtils.js");
const { readdir } = require("node:fs/promises");
class Route {
    constructor(path, method, callback) {
        this.path = path;
        this.method = method;
        this.callback = callback;
    }

    match(method, pathname) {
        if (this.method !== method) return false;
        var pathsplit = this.path.split("/");
        pathsplit.shift();
        var pathnameSplit = pathname.split("/");
        pathnameSplit.shift();
        if (pathsplit.length < pathnameSplit.length) {
            pathnameSplit[pathsplit.length - 1] = pathnameSplit.slice(pathsplit.length - 1).join("/");
            pathnameSplit.length = pathsplit.length;
        }
        const params = {};
        for (let i = 0; i < pathsplit.length; i++) {
            if (pathsplit[i].startsWith(":")) {
                params[pathsplit[i].slice(1)] = pathnameSplit[i];
                continue;
            }
            if (pathsplit[i] != pathnameSplit[i]) return false;
        }

        return { match: true, params };
    }
}

class Server {
    constructor(config) {
        this.config = config;
        this.port = config.port || 3000;
        this.Routes = [];
        this.isDev = true;
        this.DevClient = null;
        this.config.static = config.static || "./Frontend/Assets";
        this.config.components = config.components || "./Frontend/Components/";
        this.config.pages = config.pages || "./Frontend/Pages/";
        this.config.FileBaseRouting = config.FileBaseRouting || true;

        setComponentsPath(this.config.components);
        setPagesPath(this.config.pages);
        setAssetsPath(this.config.static);
        RefreshComponents();
        RefreshPages();

        BuildFonts(this.config.static + "/Fonts", this.config.static + "/Css/Fonts.css");
    }

    // Enhanced routing methods with optional middleware
    Get(path, callback) {
        this.Routes.push(new Route(path, "GET", callback));
        return this;
    }

    Post(path, callback) {
        this.Routes.push(new Route(path, "POST", callback));
        return this;
    }

    Put(path, callback) {
        this.Routes.push(new Route(path, "PUT", callback));
        return this;
    }

    Delete(path, callback) {
        this.Routes.push(new Route(path, "DELETE", callback));
        return this;
    }

    Page(path, PageName) {
        this.Get(path, async (request) => {
            return await RenderPage(PageName);
        });
    }

    // Enhanced route finding with parameter extraction
    FindRoute(request) {
        const url = new URL(request.url);
        const method = request.method;
        const pathname = url.pathname;

        for (const route of this.Routes) {
            const result = route.match(method, pathname);
            if (result && result.match) {
                return {
                    route,
                    params: result.params
                };
            }
        }
        return null;
    }

    Static(path) {
        this.Get(path + "/:file", async (request, file) => {
            return new Response(Bun.file(path + "/" + file));
        });
    }

    handleHotReload(server) {
        setPort(this.port + 1);

        Bun.serve({
            port: this.port + 1,
            fetch(req, server) {
                if (server.upgrade(req)) return;
                return new Response('Upgrade failed', { status: 400 });
            },
            websocket: {
                open: (ws) => {
                    server.DevClient = ws;
                    setDevClient(ws);
                },
                close: (ws) => {
                    server.DevClient = null;
                    setDevClient(null);
                },
                message() { }
            }
        });
    }

    runHttpServer(server) {
        const RED = '\x1b[31m';
        const GREEN = '\x1b[32m';
        const RESET = '\x1b[0m';

        Bun.serve({
            port: this.port,
            async fetch(request) {
                const startTime = performance.now();
                try {
                    const result = server.FindRoute(request);
                    const ip = request.headers.get('x-forwarded-for') || '127.0.0.1';
                    const pathname = new URL(request.url).pathname;

                    if (!result) {
                        console.log(`${RED}❌ 404   | ${ip} ${request.method} ${pathname}${RESET}`);
                        return new Response("Not Found", { status: 404 });
                    }

                    const response = await result.route.callback(request, ...Object.values(result.params));

                    const status = response.status;
                    const timing = `${Math.round(performance.now() - startTime)}ms`.padEnd(5);
                    const State = `${status == 200 ? GREEN + "✅" : RED + "❌"} ${timing}`
                    console.log(`${GREEN}${State} | ${ip} ${request.method} ${pathname}${RESET}`);

                    return response;

                } catch (error) {
                    console.error("Server error:", error);
                    const ip = request.headers.get('x-forwarded-for') || '127.0.0.1';
                    const timing = `${Math.round(performance.now() - startTime)}ms`.padEnd(5);
                    console.log(`${RED}❌ ${timing} | ${ip} ${request.method} ${new URL(request.url).pathname}${RESET}`);
                    return new Response(error.message, { status: 500 });
                }
            }
        });
    }

    OpenBrowser() {
        const url = "http://localhost:" + this.port;
        if (process.platform === "win32") {
            // Windows
            require("child_process").exec(`start ${url}`);
        } else if (process.platform === "darwin") {
            // macOS
            require("child_process").exec(`open ${url}`);
        } else {
            // Linux
            require("child_process").exec(`xdg-open ${url}`);
        }
    }

    async FileBaseRouting() {
        if (!this.config.FileBaseRouting) return;
        const path = this.config.pages;
        var files = await readdir(path, { withFileTypes: true });
        files = files.filter(file => file.isFile() && file.name.endsWith(".html"));
        // console.log(files);
        for (var file of files) {
            file = file.name.replace(".html", "");
            this.Get("/" + file, async (request) => {
                return await RenderPage(file);
            });
        }
    }
    ComponentsServer() {
        this.Get("/Components", async (request) => {
            return new Response(GetComponents(), { headers: { 'Content-Type': 'application/json' } });
        });
    }
    // Start server with enhanced routing and error handling
    Start() {
        const server = this;
        this.ComponentsServer();
        this.FileBaseRouting();
        this.Static(this.config.static);
        this.runHttpServer(server);
        console.log(`✅ Server started on http://127.0.0.1:${this.port}\n${this.config.hotReload ? "✅ Hot Reload Enabled on ws://127.0.0.1:" + (this.port + 1) : "❌ Hot Reload Disabled"}`);
        if (this.config.openBrowser) this.OpenBrowser();
        if (this.config.hotReload) {
            this.handleHotReload(server);
            // console.log(`Hot reload WebSocket server started on ws://127.0.0.1:${this.port + 1}`);
        }

    }
}


module.exports = { Server };