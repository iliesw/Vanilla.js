class Components {
    static Cache = new Map();
}

class Vanilla {
    static port = parseInt(window.location.port) + 1;

    static async Init(Plugins) {
        this.Plugins = Plugins;
        console.group('%cVanilla 0.0.1',
            `padding: 5px;padding-left: 10px;
            color: yellow;
            text-shadow: 
            0 0 5px yellow, 
            0 0 10px yellow;
            font-size: 18px;
            `);
        console.time('Initialization');
        await this.HotReload();
        await this.LoadComponents();
        await this.CreateComponentFunctions();
        await this.InitMutationObserver();
        await this.ApplyPluginsOnLoaded();
        console.timeEnd('Initialization');
        console.groupEnd();
    }

    static async LoadComponents() {
        const components = await fetch("/Components").then(res => res.json());
        Components.Cache = new Map(Object.entries(components));
        console.log('%cLoaded ' + Components.Cache.size + ' Components ✓', 'color: green; font-weight: bold;');
    }
    static async CreateComponentFunctions() {
        for (const [key, value] of Components.Cache) {
            Components[key] = async (props = {}) => {
                let template = value;
                const propsToReplace = template.match(/{(.*?)}/g) || [];
                for (const prop of propsToReplace) {
                    const propName = prop.slice(1, -1); // Remove { and }
                    if (props[propName]) {
                        template = template.replace(prop, props[propName]);
                    }
                }
                const tempDiv = document.createElement('div');
                tempDiv.innerHTML = template;
                const component = tempDiv.firstElementChild;
                await this.ApplyPlugins(component);
                return component;
            }
        }
        console.log('%cCreated Component Functions ✓', 'color: green; font-weight: bold;');
    }
    static async InitMutationObserver() {
        var changed = [];
        const callback = (mutationList) => {
            for (const mutation of mutationList) {
                if (mutation.type === 'childList') {
                    // Handle added nodes
                    mutation.addedNodes.forEach(node => {
                        if (!changed.includes(node)) {
                            changed.push(node);
                            this.OnChange(node);
                        }
                    });

                    // Handle removed nodes
                    mutation.removedNodes.forEach(node => {
                        const index = changed.indexOf(node);
                        if (index > -1) {
                            changed.splice(index, 1);
                        }
                    });
                }
            }
        };
        const observer = new MutationObserver(callback);
        observer.observe(document.body, {
            childList: true, // Detect added or removed elements
            subtree: true,   // Monitor the whole DOM tree
        });
        console.log('%cInitialized Mutation Observer ✓', 'color: green; font-weight: bold;');
    }
    static async HotReload() {
        return new Promise((resolve) => {
            const ws = new WebSocket(`ws://localhost:${this.port}`);
            ws.onmessage = (event) => {
                if (event.data === 'reload') {
                    window.location.reload();
                }
            };
            ws.onopen = () => {
                console.log('%cConnected to Hot Reload ✓', 'color: green; font-weight: bold;');
                resolve();
            };
            ws.onclose = () => console.log('%cDisconnected from Hot Reload', 'color: red; font-weight: bold;');
        });
    }

    static OnChange(node) {
        // console.log(node);
    }

    static async ApplyPlugins(component) {
        for (const [key, value] of Object.entries(this.Plugins)) {
            await this.Plugins[key](component);
        }
    }

    static async ApplyPluginsOnLoaded() {
        for (const component of document.body.getElementsByTagName("*")) {
            if (component.nodeType === 3) continue; // Ignore text nodes
            await this.ApplyPlugins(component);
        }
    }
}

const VanillaPlugins = {}
VanillaPlugins.Fetch = async (component) => {

    const isFetching = component.hasAttribute('GET') || component.hasAttribute('POST') || component.hasAttribute('PUT') || component.hasAttribute('DELETE');
    const url = component.getAttribute('GET') || component.getAttribute('POST') || component.getAttribute('PUT') || component.getAttribute('DELETE');
    const method = component.hasAttribute('GET') ? 'GET' :
        component.hasAttribute('POST') ? 'POST' :
            component.hasAttribute('PUT') ? 'PUT' :
                component.hasAttribute('DELETE') ? 'DELETE' : '';

    const Replace = component.getAttribute('Replace') || "inner"; // Default to inner if no replace attribute is specified


    if (isFetching) {
        component.removeAttribute(method);
        const _data = await fetch(url, { method: method }).then(res => res.text());
        switch (Replace) {
            case "inner": component.innerHTML = _data; break;
            case "outer": component.outerHTML = _data; break;
            case "before": component.insertAdjacentHTML('beforebegin', _data); break;
            case "after": component.insertAdjacentHTML('afterend', _data); break;
            case "start": component.insertAdjacentHTML('afterbegin', _data); break;
            case "end": component.insertAdjacentHTML('beforeend', _data); break;
            case "children": const children = component.children; component.innerHTML = _data; component.append(...children); break;
            case "text": component.textContent = _data; break;
            default: console.warn(`Unknown Replace option "${Replace}" on node:`, component); break;
        }
    }
}
VanillaPlugins.DataFetch = async (component) => {
    const isDataFetching = component.hasAttribute('Data:GET') || component.hasAttribute('Data:POST') || component.hasAttribute('Data:PUT') || component.hasAttribute('Data:DELETE');
    const url = component.getAttribute('Data:GET') || component.getAttribute('Data:POST') || component.getAttribute('Data:PUT') || component.getAttribute('Data:DELETE');
    const method = component.hasAttribute('Data:GET') ? 'GET' :
        component.hasAttribute('Data:POST') ? 'POST' :
            component.hasAttribute('Data:PUT') ? 'PUT' :
                component.hasAttribute('Data:DELETE') ? 'DELETE' : '';
    if (isDataFetching) {
        component.removeAttribute('Data:' + method);
        const Data = await fetch(url).then(res => res.json());
        for (const [key, value] of Object.entries(Data)) {
            component.setAttribute(key, value);
        }
    }
}
VanillaPlugins.RefreshTemplate = (component) => {
    var template = component.innerHTML;
    const propsToReplace = template.match(/{(.*?)}/g) || [];
    for (const prop of propsToReplace) {
        const propName = prop.slice(1, -1); // Remove { and }
        template = template.replace(prop, component.getAttribute(propName));
        component.removeAttribute(propName)
    }
    component.innerHTML = template;
}


window.onload = () => Vanilla.Init(VanillaPlugins);